### line 

``` 
从最开始的常数驱动的绘制精度，到根据实际坐标绘制（根据不同的斜率）决定从哪个方向开始绘制。最后进行的优化是根据像素来绘制的，通过一个斜率（也就是误差），来决定在绘制中y的偏移量。再次的改进是将float 变为int 的形式去加速计算和比较，  

int dx = x1 - x0;<br>
int dy = y1 - y0;<br>
int derror2 = std::abs(dy) * 2;<br>
int error2 = 0;//实际上就是直接将原来的斜率误差（和处理规则）等比放大
 ```

 ### 画线
 
 1. 使用相似的原理，和循环（在x坐标轴上）找到每一个对应的像素，然后设置为对应的颜色
 2. 问题：精度的问题，如果斜率较高，或是x0>x1;都会有点问题
 3.  改进：如果斜率过大，就把y和x的值换一下，变成y上面的循环，如果初始的x0>x1，就呼唤这两个坐标，保证是从左向有绘制的。

 4. 本来这样是完全没有问题的，但是 编写测试程序和使用gcc 编译，查看各个函数的时间花费。发现line 这个函数调用的时间过长。所以我们是一定要优化这个函数。

 5. 首先，这里直接给出结论：时间主要花费在进行相似的运算时，这个数学的运算尤其要注意，根号，除法，是极端花费时间的，绝不能每次重复都用；
 
 6. 使用误差驱动的设计思想。也就是说：同样是对每一个格子的一个轴进行遍历，但是y轴上的更新不再是直接算出应有的位置，而是将derror=dy/dx;每次都是这样一个误差的叠加，当误差>.5时，将对应的y的向下移，然后误差-1；

 7. float 的运算和判断是一定小于 int 类型的，所以我们将涉及到的判断的数据全部进行缩放:就是将涉及到的最小的数放大到整数；